Design Decisions/Codebase Overview:

Within Scheduling System. the same Event object can be contained in multiple Schedules.
Internal aliasing is what allows for Events (and thus information)
to be shared between different users.

Two Event objects can be compared with equality if they share the same state. This is how the
Scheduling System accesses a specific Event within a Schedule.

A user of the System can identify a unique Event in a schedule through its start day and time.
This is due to the following INVARIANT: every Event contained WITHIN a Schedule NEVER CONFLICTS.
What constitutes a conflicting event was defined by Nunez, as non-overlapping Events (except if
end and start of event are same).

A Scheduling System is a collection of Schedules. If the above is enforced for a single Schedule,
the Scheduling System as a whole enforces that an Event WITHIN the Scheduling System NEVER CONFLICTS
with ANY Schedule the Event is related to (through its invitee list). The event-conflict
public method exists for this very purpose.

Since creating an XML file of a user's schedule can be interpreted as the View's job
(producing XML is essentially rendering the current state of the model aka scheduling system),
the conversion of an existing schedule to XML has been delegated to the View.

Since reading in an XML file to manipulate the state of the model according to "user" input (XML
itself) can be interpreted as the controller's job, creating or adding to user
schedule has been delegated to the Controller.

View accesses (Readable-only) Events through the Model. This allows for a one-way flow of info.
Observations on an Event have been put into a Readable-only Event interface, with the complete
Event interface (operations included) extending ReadableEvent.
        The View can anyways only access copies of the Events contained within the Scheduling System
        but the inclusion of the Readable interface prevents any developer working on the View
        to even attempt to manipulate an event and thus affect model-state.

Every component gives out a DEFENSIVE COPY of whatever it provides,
removing weird external aliasing dependencies.

(FUTURE NOTE, PLEASE READ TAS:
- Will be refactoring Scheduling System addEvent and eventConflict method to only accept an Event
rather than parameters than construct an Event, because it feels like data representation of an
Event is being rigidly defined/leaked in Scheduling System interface. This change would not take
long because of my codebase design,
but this refactor is being prevented due to the numerous tests written with the current
addEvent + eventConflict method signature and time constraint.)

Key components:
Explain the highest-level components in your system, and what they do.
It is trite and useless to merely say “The model represents the data in my system.
The view represents the rendering of my system. ...”
This is a waste of your time and the reader’s time.
Describe which components “drive” the control-flow of your system, and which ones “are driven”.

Key subcomponents:
Within each component, give an overview of the main nouns in your system,
and why they exist and what they are used for.

Quick Start:
Key Components (mentioned in overview, so this section kept brief):
Scheduling System stores user Schedules, and user Schedules store Events. Scheduling System is the
model, which runs on Schedules, which runs on Events.

The SSView interacts with the Scheduling System to render a user's Schedule using Events,
in either XML or text format.

The SSController is to manipulate the Scheduling System right now with only XML.

Smaller Components:
DaysOfTheWeek is an enum used to keep track of the days for a 2-week span planner.

Source organization:
All components in src and test are contained within cs3500.nuplanner package.



Added observation method to ReadableEvent
Planning to change modifyEvent method of model to modifyEvent(new Event1, new Event2);
Created Features interface and bare-bones controller
Features interface prone to change/not properly linked to EventFrame yet






Other considerations:
- if an XML file mentions "non-existing" (not present in scheduling system) users, add them into
  create accounts for them ONLY IF entire XML File upload succeeds
- same thing for user manually creating a new event -> non-existing invitees automatically addeed

- XML files cannot OVERWRITE a schedule, only create or ADD to one/multiple