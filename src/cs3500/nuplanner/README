Design Decisions/Codebase Introduction:

Within Scheduling System. the same Event object can be contained in multiple Schedules.
Internal aliasing is what allows for Events (and thus information)
to be shared between different users.

Two Event objects can be compared with equality if they share the same state. This is how the
Scheduling System accesses a specific Event within a Schedule.

A user of the System can identify a unique Event in a schedule through its start day and time.
This is due to the following INVARIANT: every Event contained WITHIN a Schedule NEVER CONFLICTS.
What constitutes a conflicting event was defined by Nunez, as non-overlapping Events (except if
end and start of event are same).

A Scheduling System is a collection of Schedules. If the above is enforced for a single Schedule,
the Scheduling System as a whole enforces that an Event WITHIN the Scheduling System NEVER CONFLICTS
with ANY Schedule the Event is related to (through its invitee list). The event-conflict
public method exists for this very purpose.

Since creating an XML file of a user's schedule can be interpreted as the View's job
(producing XML is essentially rendering the current state of the model aka scheduling system),
the conversion of an existing schedule to XML has been delegated to the View.

Since reading in an XML file to manipulate the state of the model according to "user" input (XML
itself) can be interpreted as the controller's job, creating or adding to user
schedule has been delegated to the Controller.

View accesses (Readable-only) Events through the Model. This allows for a one-way flow of info.
Observations on an Event have been put into a Readable-only Event interface, with the complete
Event interface (operations included) extending ReadableEvent.
        The View can anyways only access copies of the Events contained within the Scheduling System
        but the inclusion of the Readable interface prevents any developer working on the View
        to even attempt to manipulate an event and thus affect model-state.

Every component gives out a DEFENSIVE COPY of whatever it provides,
removing weird external aliasing dependencies.

FUTURE NOTE, PLEASE READ TAS:
- Will be refactoring Scheduling System addEvent and eventConflict method to only accept an Event
rather than parameters than construct an Event, because it feels like data representation of an
Event is being rigidly defined/leaked. This change would not take long because of my codebase design,
but this refactor is being prevented due to the numerous tests written with the current
addEvent method signature and time constraint.

Other considerations:
- if an XML file mentions "non-existing" (not present in scheduling system) users, add them into
  create accounts for them ONLY IF entire XML File upload succeeds
- same thing for user manually creating a new event -> non-existing invitees automatically addeed

- XML files cannot OVERWRITE a schedule, only create or ADD to one/multiple