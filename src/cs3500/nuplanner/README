Design Decisions/Codebase Overview: (Person who has received our group, PLEASE read Changes for HW7)

Within Scheduling System. the same Event object can be contained in multiple Schedules.
Internal aliasing is what allows for Events (and thus information)
to be shared between different users.

Two Event objects can be compared with equality if they share the same state. This is how the
Scheduling System accesses a specific Event within a Schedule.

A user of the System can identify a unique Event in a schedule through its start day and time.
This is due to the following INVARIANT: every Event contained WITHIN a Schedule NEVER CONFLICTS.
What constitutes a conflicting event was defined by Nunez, as non-overlapping Events (except if
end and start of event are same).

A Scheduling System is a collection of Schedules. If the above is enforced for a single Schedule,
the Scheduling System as a whole enforces that an Event WITHIN the Scheduling System NEVER CONFLICTS
with ANY Schedule the Event is related to (through its invitee list). The event-conflict
public method exists for this very purpose.

Since creating an XML file of a user's schedule can be interpreted as the View's job
(producing XML is essentially rendering the current state of the model aka scheduling system),
the conversion of an existing schedule to XML has been delegated to the View.

Since reading in an XML file to manipulate the state of the model according to "user" input (XML
itself) can be interpreted as the controller's job, creating or adding to user
schedule has been delegated to the Controller.

View accesses (Readable-only) Events through the Model. This allows for a one-way flow of info.
Observations on an Event have been put into a Readable-only Event interface, with the complete
Event interface (operations included) extending ReadableEvent.
        The View can anyways only access copies of the Events contained within the Scheduling System
        but the inclusion of the Readable interface prevents any developer working on the View
        to even attempt to manipulate an event and thus affect model-state.

Every component gives out a DEFENSIVE COPY of whatever it provides,
removing weird external aliasing dependencies.

GUI requests high level FEATURES from whatever implements features, in order to completely contain
View's implementation details. The essence of what Features does is permit the View to change its
state, and to manipulate model state. Changing model and view state is equivalent to the controller
job, thus controller implements the Features interface.

The SSGUIView is the Main View that takes in a Readable model and is given to Controller, and allows
the user to view multiple schedules, interact with existing events, upload and download schedules,
and create new events.

An EventView is created and destroyed within the overarching SSGUIView Interface, and allows the
user to modify and remove existing events, as well as create new events.

In the EventView, the user must place information into the given text boxes and then request
their desired action. To add multiple users to a new event, the user must select multiple users
in the Available Users box. To remove attending users from an existing event, the user must select
the multiple attending users in the same box (and press modify).

In the EventView, the host of an existing event user clicks on is highlighted green,
while the non-host members arehighlighted blue.


Key Components (mentioned in overview, so this section kept brief):

The SSView interacts with the Scheduling System to render a user's Schedule using Events,
in either XML or text format.

The SSController is to manipulate the Scheduling System with GUI input discussed above, or XMl
input.


Smaller Components:

DaysOfTheWeek is an enum used to keep track of the days for a 2-week span planner.


Source organization:

All components in src and test are contained within cs3500.nuplanner package.
All components relevant to GUI are in the cs3500.nuplanner.view.gui package.


CHANGES FOR HW 6:

Added observation method to ReadableEvent to check whether a given time is contained within an
Event's range. Observes state of Event.

Planning to change modifyEvent method signature of model interface to
modifyEvent(new Event1, new Event2) due to perceived limitations in current model design.
This is to allow a User to change multiple aspects of an Event at once.

Created Features interface and bare-bones controller. Brief reasoning given in Intro to Codebase.

CHANGES FOR HW 7:
- Behavior of an Event slightly modified -> an Event can now
- Codebase is right now hardcoded with only one representation of time: military time
    - biggest oversight for this project (lesson learned) <- can be easily changed if had 12hrs
    - NUEvent impl set to only work with military time
    - SchedulingSystem (model) impl assumes time passed in is either valid or invalid military time
    - Schedule impl assumes that an Event given to it (at interface level) work with military time
    - View assumes all Events given to it (at interface level) work with military time
    - ^ first step to fixing this assumption is to decouple time rep from Event (not hard)
    - When we say assume, we mean that there are still checks in place to reject invalid
        military time (mainly, it is impossible to create an Event with invalid military time),
        but again, codebase can only work with military time
    - In future, will need to create a Time-class to make codebase more flexible and compatible with
      any representation of Time. Due to time constraints between my partner and I, this has not
      been accomplished before the HW7 deadline.

REASONING FOR NOT IMPLEMENTING TIME CLASS AFTER TA FEEDBACK: Will be doing so after Exam 2.
However as justification for no time class, an Event itself ensures that the time used to construct
it is in military time. Once an Event is instantiated, it can only represent time in military time.
Any start-time provided by user that IS NOT MILITARY TIME will cause the relevant Event to throw an
IllegalArgException. Any times passed between components will be extracted from existing Events
that have proper military time, or rejected by an Event due to improper military time.
Summary:
The Event implementation ITSELF ENFORCES MILITARY TIME.



HW7
- changed removeEvent and modifyEvent signatures


- need to update modify event signature - think about other model method sigs
- need to use a Time class (discuss with TA, benefits again)
- need to clean up code/javadocs <-- some are quite bad <-- think about what information should be interface vs impl level
-

if have time (prob won't):
- think about the use of objective values everywhere --> always converting from military time to ov
    - bunch of duplicate code in multiple components for that conversion



- Will be refactoring Scheduling System addEvent and eventConflict method to only accept an Event
rather than parameters than construct an Event, because it feels like data representation of an
Event is being rigidly defined/leaked in Scheduling System interface. This change would not take
long because of my codebase design,
but this refactor is being prevented due to the numerous tests written with the current
addEvent + eventConflict method signature and time constraint.)
